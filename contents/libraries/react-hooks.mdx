---
title: "React Mastery"
description: "React Test"
order: 4
---
# React Hooks Comprehensive Guide

## Introduction

React Hooks revolutionized functional components by enabling state management and side effects. This guide covers core hooks with detailed explanations, best practices, and interactive examples.

---

## useState

<ProTip title="Pro Tip">
  Hooks let you use state and other React features without writing classes.
  useState is the most fundamental hook for managing local component state.
</ProTip>

<CodeBlock language="jsx" showCopyButton={true}>
{`import React, { useState } from 'react';

function Counter() {
// Declare state variable 'count' with initial value 0
// setCount is the updater function
const [count, setCount] = useState(0);

return (

<div>
  <p>You clicked {count} times</p>
  <button onClick={() => setCount(count + 1)}>Increment</button>
  <button onClick={() => setCount((prevCount) => prevCount - 1)}>
    Decrement (functional update)
  </button>
</div>
); }`}

</CodeBlock>

<CommonMistake title="Common Mistake">
  Never update state directly (e.g., count = 5) — always use the setter function
  to avoid stale closures and ensure proper reactivity.
</CommonMistake>

<Callout type="info" title="Performance Consideration">

    Avoid complex logic inside the render method — move expensive computations
    to useMemo or useEffect to prevent performance bottlenecks.

</Callout>

---

## useEffect

<ProTip title="Advanced Usage">
  useEffect combines componentDidMount, componentDidUpdate, and
  componentWillUnmount. It's ideal for data fetching, subscriptions, and manual
  DOM manipulations.
</ProTip>

<CodeBlock language="jsx" showCopyButton={true} requireLogin={true}>
{`import React, { useState, useEffect } from 'react';

function UserProfile({ userId }) {
const [user, setUser] = useState(null);
const [loading, setLoading] = useState(false);

// Effect with cleanup and dependency
useEffect(() => {
let isMounted = true;

    const fetchUser = async () => {
      setLoading(true);
      try {
        const response = await fetch(\`/api/users/\${userId}\`);
        const data = await response.json();
        if (isMounted) setUser(data);
      } catch (error) {
        console.error('Fetch error:', error);
      } finally {
        if (isMounted) setLoading(false);
      }
    };

    fetchUser();

    // Cleanup function
    return () => {
      isMounted = false;
      // Cancel any pending requests here if needed
    };

}, [userId]); // Only re-run if userId changes

if (loading) return <div>Loading...</div>;
if (!user) return <div>No user found</div>;

return (

<div>
  <h2>{user.name}</h2>
  <p>{user.bio}</p>
</div>
); }`}

</CodeBlock>

<CommonMistake title="Critical Error">
  Forgetting the dependency array can lead to infinite loops. However,
  over-specifying dependencies can cause unnecessary re-renders. Find the right
  balance.
</CommonMistake>

<Callout type="info" title="Architecture Tip">
  You can (and should) use multiple useEffect calls to separate unrelated logic
  into different effects for better maintainability.
</Callout>


---

## useRef

<ProTip title="Beyond DOM References">
  While commonly used for DOM access, useRef is also perfect for storing any
  mutable value that should persist between renders without causing re-renders.
</ProTip>

<CodeBlock language="jsx" showCopyButton={true} requireLogin={false}>
{`import React, { useRef, useEffect } from 'react';

function FocusInput() {
const inputRef = useRef(null);
const renderCount = useRef(0);

useEffect(() => {
// Focus the input on mount
inputRef.current.focus();

    // Track render count (won't trigger re-render)
    renderCount.current += 1;
    console.log(\`Rendered \${renderCount.current} times\`);

}, []);

return (

<div>
  <input ref={inputRef} type="text" />
  <button onClick={() => inputRef.current.focus()}>Focus Input</button>
</div>
); }`}

</CodeBlock>

<CommonMistake title="Misconception">
  Don't confuse useRef with createRef from class components. useRef maintains
  the same reference across re-renders while createRef creates a new reference
  each time.
</CommonMistake>

<Callout type="info" title="Advanced Pattern">
  useRef is invaluable for keeping track of previous state values by combining
  with useEffect to "remember" past values.
</Callout>

---

## useMemo

<ProTip title="Optimization Strategy">
  useMemo memoizes expensive computations, preventing recalculation on every
  render when dependencies haven't changed.
</ProTip>

<CodeBlock language="jsx" showCopyButton={true} requireLogin={true}>
{`import React, { useMemo } from 'react';

function ExpensiveComponent({ list, filterTerm }) {
const filteredList = useMemo(() => {
console.log('Recalculating filtered list...');
return list.filter(item =>
item.name.toLowerCase().includes(filterTerm.toLowerCase())
);
}, [list, filterTerm]); // Only recalculate when list or filterTerm changes

return (

<ul>
  {filteredList.map((item) => (
    <li key={item.id}>{item.name}</li>
  ))}
</ul>
); }`}

</CodeBlock>

<CommonMistake title="Premature Optimization">
  Don't overuse useMemo — the overhead of memoization might outweigh the
  benefits for simple computations. Profile first!
</CommonMistake>

<Callout type="warning" title="Dependency Warning">
  Incorrect dependency arrays can lead to stale values. Consider using the
  ESLint exhaustive-deps rule to catch these issues.
</Callout>

---

## useCallback

<ProTip title="Performance Optimization">
  useCallback memoizes functions themselves, preventing unnecessary recreations
  that could trigger child component re-renders.
</ProTip>

<CodeBlock language="jsx" showCopyButton={true} requireLogin={true}>
{`import React, { useState, useCallback } from 'react';
import MemoizedChild from './MemoizedChild';

function ParentComponent() {
const [count, setCount] = useState(0);
const [value, setValue] = useState('');

// Without useCallback, this would be recreated on every render
// causing MemoizedChild to re-render unnecessarily
const increment = useCallback(() => {
setCount(c => c + 1);
}, []); // No dependencies - function never changes

// With dependency - recreates when value changes
const logValue = useCallback(() => {
console.log(\`Current value: \${value}\`);
}, [value]);

return (

<div>
  <button onClick={increment}>Count: {count}</button>
  <input value={value} onChange={(e) => setValue(e.target.value)} />
  <MemoizedChild onLog={logValue} />
</div>
); }`}

</CodeBlock>

<CommonMistake title="Common Pitfall">
  Missing dependencies in useCallback can lead to stale closures where the
  function captures old values from previous renders.
</CommonMistake>

<Callout type="info" title="Best Practice">
  Combine useCallback with React.memo for optimal performance in component trees
  with frequent re-renders.
</Callout>
